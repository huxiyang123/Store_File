1 装饰模式又名包装(Wrapper)模式。就是动态地给一个对象添加一些额外的职责，就好比为房子进行装修一样。
2 装饰器模式具有如下的特征：
它必须具有一个装饰的对象。
它必须拥有与被装饰对象相同的接口。
它可以给被装饰对象添加额外的功能。
用一句话总结就是：保持接口，增强性能。
3 通常给对象添加新功能，要么直接修改对象添加，要么派生对应的子类来扩展，抑或是使用对象组合的方式。
4 装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。
5  Component：组件对象的接口，可以给这些对象动态的添加职责；

    ConcreteComponent：具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责；

    Decorator：所有装饰器的父类，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。

    ConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。

6 在以下两种情况下可以考虑使用装饰器模式：

    (1)需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责。

    (2)如果不适合使用子类来进行扩展的时候，可以考虑使用装饰器模式。
7 装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为
